// ============================================================================
// LLTY PRESALE - WORKING WALLET PROVIDER FIX
// Uses useAppKitProvider() hook from Reown AppKit
// ============================================================================

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { useAppKit, useAppKitAccount, useAppKitProvider } from '@reown/appkit/react';
import {
  Connection,
  PublicKey,
  SystemProgram,
  LAMPORTS_PER_SOL,
} from '@solana/web3.js';
import {
  TOKEN_PROGRAM_ID,
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction
} from '@solana/spl-token';
import { BN } from '@coral-xyz/anchor';
import { debounce } from 'lodash';
import { createJupiterApiClient } from '@jup-ag/api';
import { CheckCircle, AlertCircle, Clock } from 'lucide-react';

// Services & Libraries
import blockchainService from './services/blockchainService';
import stakingService from './services/stakingService';
import governanceService from './services/governanceService';
import { supabase, dbHelpers } from './lib/supabase';
import { captureError, captureMessage } from './lib/sentry';

// Hooks
import { useStaking } from './hooks/useStaking';
import { useGovernance } from './hooks/useGovernance';

import { BLOCKCHAIN_CONFIG } from './config/blockchain-config';
import { PRESALE_PHASES, getCurrentPhase } from './config/presale-timing-config';
import usePresaleTiming from './hooks/usePresaleTiming';
import purchaseService from './services/purchaseService';

// Components
import Header from './components/layout/Header';
import Footer from './components/layout/Footer';
import HeroSection from './components/sections/HeroSection';
import VIPSection from './components/sections/VIPSection';
import BonusTiersSection from './components/sections/BonusTiersSection';
import ReferralSection from './components/sections/ReferralSection';
import BuySection from './components/presale/BuySection';
import TokenomicsSection from './components/sections/TokenomicsSection';
import RoadmapSection from './components/sections/RoadmapSection';
import AboutSection from './components/sections/AboutSection';
import CitiesSection from './components/sections/CitiesSection';
import SecuritySection from './components/sections/SecuritySection';
import StakingSection from './components/sections/StakingSection';
import GovernanceSection from './components/sections/GovernanceSection';
import LLTYLogo from './components/LLTYLogo.jsx';
// Translations
import { translations } from './i18n/translations';

// ============================================================================
// CONSTANTS & CONFIGURATION
// ============================================================================
const NETWORK = 'devnet';
const RPC_ENDPOINT = BLOCKCHAIN_CONFIG.rpcEndpoint;

const ADDRESSES = {
  PROGRAM_ID: BLOCKCHAIN_CONFIG.programId.toString(),
  LLTY_MINT: BLOCKCHAIN_CONFIG.lltyMint.toString(),
  USDC_MINT: BLOCKCHAIN_CONFIG.usdcMint.toString(),
  USDT_MINT: BLOCKCHAIN_CONFIG.usdtMint.toString(),
  PRESALE_PDA: BLOCKCHAIN_CONFIG.presalePda.toString(),
  LLTY_VAULT: BLOCKCHAIN_CONFIG.lltyVault.toString(),
  USDC_VAULT: BLOCKCHAIN_CONFIG.usdcVault.toString(),
  USDT_VAULT: BLOCKCHAIN_CONFIG.usdtVault.toString(),
};

const PHASE_DURATION = 14 * 24 * 60 * 60 * 1000;

const PHASE_PRICES_DISPLAY = {
  vip: 0.001,
  1: 0.004,
  2: 0.005,
  3: 0.006
};

const PHASE_ALLOCATIONS = {
  1: 1_000_000_000,
  2: 1_500_000_000,
  3: 1_500_000_000
};

const PRESALE_TARGET = (
  (PHASE_ALLOCATIONS[1] * PHASE_PRICES_DISPLAY[1]) +
  (PHASE_ALLOCATIONS[2] * PHASE_PRICES_DISPLAY[2]) +
  (PHASE_ALLOCATIONS[3] * PHASE_PRICES_DISPLAY[3])
);

const citiesData = [
  { name: 'Amman, Jordan', image: 'https://images.unsplash.com/photo-1578894381163-e72c17f2d45f?w=800' },
  { name: 'Dubai, UAE', image: 'https://images.unsplash.com/photo-1512453979798-5ea266f8880c?w=800' },
  { name: 'Abu Dhabi, UAE', image: 'https://images.unsplash.com/photo-1512632578888-169bbbc64f33?w=800' },
  { name: 'Riyadh, Saudi Arabia', image: 'https://images.unsplash.com/photo-1591608971362-f08b2a75731a?w=800' },
  { name: 'Jeddah, Saudi Arabia', image: 'https://images.unsplash.com/photo-1586724237569-f3d0c1dee8c6?w=800' },
  { name: 'Cairo, Egypt', image: 'https://images.unsplash.com/photo-1539768942893-daf53e448371?w=800' },
  { name: 'Beirut, Lebanon', image: 'https://images.unsplash.com/photo-1580922090158-85e89c1d9c9e?w=800' },
  { name: 'Doha, Qatar', image: 'https://images.unsplash.com/photo-1574164047321-cc3a85cc5e6d?w=800' },
  { name: 'Kuwait City, Kuwait', image: 'https://images.unsplash.com/photo-1577699113768-7a5e25863083?w=800' },
];

// ============================================================================
// MAIN APP COMPONENT
// ============================================================================
const App = () => {
  // Centralized timing
  const timing = usePresaleTiming();
  const currentPhase = timing.phaseNumber === 1 ? 0 : timing.phaseNumber - 1;
  const isVipPeriod = timing.isVipPhase;
  const presaleEnded = timing.hasEnded;
  const phaseTimeRemaining = timing.timeRemaining;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // WALLET & CONNECTION - âœ… CRITICAL FIX: Added useAppKitProvider
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const { open, disconnect } = useAppKit();
  const { address, isConnected } = useAppKitAccount();
  const { walletProvider } = useAppKitProvider('solana'); // âœ… THIS IS THE KEY FIX!
  const connection = useMemo(() => new Connection(RPC_ENDPOINT, 'confirmed'), []);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // CUSTOM HOOKS - STAKING & GOVERNANCE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const stakingData = useStaking(address, connection);
  const governanceData = useGovernance(address, connection);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STATE: BALANCES
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const [balance, setBalance] = useState(0);
  const [walletBalances, setWalletBalances] = useState({
    SOL: 0,
    USDC: 0,
    USDT: 0
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STATE: TRANSACTION
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const [loading, setLoading] = useState(false);
  const [txSignature, setTxSignature] = useState('');
  const [txStatus, setTxStatus] = useState('');
  const [balancesLoading, setBalancesLoading] = useState(false);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STATE: PURCHASE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const [amount, setAmount] = useState('');
  const [currency, setCurrency] = useState('USDC');
  const [calculatedTokens, setCalculatedTokens] = useState(0);
  const [bonusPercentage, setBonusPercentage] = useState(0);
  const [purchased, setPurchased] = useState(0);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STATE: UI
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const [lang, setLang] = useState('ar');
  const [menuOpen, setMenuOpen] = useState(false);
  const [notification, setNotification] = useState({
    show: false,
    type: '',
    message: ''
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STATE: PRESALE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const [vipBuyersCount, setVipBuyersCount] = useState(0);
  const [totalRaised, setTotalRaised] = useState(0);
  const [totalLLTYSold, setTotalLLTYSold] = useState(0);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STATE: CAROUSEL & PRICING
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const [currentCityIndex, setCurrentCityIndex] = useState(0);
  const [solPrice, setSolPrice] = useState(0);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // COMPUTED VALUES
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const t = translations[lang];

  const roadmapData = [
    {
      quarter: translations[lang].navigation.q1_2026,
      title: translations[lang].navigation.presale_launch,
      desc: translations[lang].navigation.presale_launch_desc,
    },
    {
      quarter: translations[lang].navigation.q2_2026,
      title: translations[lang].navigation.smart_contract_audit,
      desc: translations[lang].navigation.smart_contract_audit_desc,
    },
    {
      quarter: translations[lang].navigation.q3_2026,
      title: translations[lang].navigation.mainnet_launch,
      desc: translations[lang].navigation.mainnet_launch_desc,
    },
    {
      quarter: translations[lang].navigation.q4_2026,
      title: translations[lang].navigation.first_property,
      desc: translations[lang].navigation.first_property_desc,
    },
    {
      quarter: translations[lang].navigation.q1_2027,
      title: translations[lang].navigation.dex_listing,
      desc: translations[lang].navigation.dex_listing_desc,
    },
    {
      quarter: translations[lang].navigation.q2_2027,
      title: translations[lang].navigation.expansion_5_cities,
      desc: translations[lang].navigation.expansion_5_cities_desc,
    },
    {
      quarter: translations[lang].navigation.q3_2027,
      title: translations[lang].navigation.mobile_app,
      desc: translations[lang].navigation.mobile_app_desc,
    },
    {
      quarter: translations[lang].navigation.q4_2027,
      title: translations[lang].navigation.portfolio_20_properties,
      desc: translations[lang].navigation.portfolio_20_properties_desc,
    },
  ];

  const progressPercentage = Math.min((totalRaised / PRESALE_TARGET) * 100, 100);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // UTILITY FUNCTIONS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const shortenAddress = (address) => {
    if (!address) return '';
    return `${address.slice(0, 4)}...${address.slice(-4)}`;
  };

  const scrollToSection = (id) => {
    setMenuOpen(false);
    const element = document.getElementById(id);
    if (element) {
      element.scrollIntoView({ behavior: 'smooth' });
    }
  };

  const showNotification = useCallback((type, message, duration = 5000) => {
    setNotification({ show: true, type, message });
    if (duration > 0) {
      setTimeout(() => {
        setNotification(prev => ({ ...prev, show: false }));
      }, duration);
    }
  }, []);

  const calculateBonus = (usdAmount) => {
    if (usdAmount >= 10000) return 15;
    if (usdAmount >= 5000) return 10;
    if (usdAmount >= 1000) return 5;
    return 0;
  };

  const getUrgencyMessage = () => {
    if (isVipPeriod) {
      return lang === 'ar' ? 'âš¡ ÙØªØ±Ø© VIP Ù†Ø´Ø·Ø©! ÙÙ‚Ø· 50 Ù…Ù‚Ø¹Ø¯ Ù…ØªØ§Ø­!' : 'âš¡ VIP Period Active! Only 50 Slots!';
    }
    const hoursLeft = Math.floor(phaseTimeRemaining.days * 24 + phaseTimeRemaining.hours);
    if (hoursLeft < 24) {
      return lang === 'ar' ? 'âš¡ Ø£Ù‚Ù„ Ù…Ù† 24 Ø³Ø§Ø¹Ø© Ù„Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ!' : 'âš¡ Less than 24 hours at this price!';
    }
    if (hoursLeft < 72) {
      return lang === 'ar' ? 'ğŸ”¥ Ø§Ù„Ø³Ø¹Ø± ÙŠØ±ØªÙØ¹ Ù‚Ø±ÙŠØ¨Ø§Ù‹!' : 'ğŸ”¥ Price increasing soon!';
    }
    return lang === 'ar' ? 'â° ÙˆÙ‚Øª Ù…Ø­Ø¯ÙˆØ¯ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¹Ø±' : 'â° Limited time at this price';
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // BLOCKCHAIN FUNCTIONS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const fetchBalances = async (showLoadingIndicator = true) => {
    if (!isConnected || !address) {
      console.warn('Cannot fetch balances: not connected');
      return;
    }

    if (showLoadingIndicator) {
      setLoading(true);
      setBalancesLoading(true);
    }

    try {
      const pubKey = new PublicKey(address);
      console.log('ğŸ” Fetching balances from blockchain...');

      const result = await blockchainService.fetchAllBalances(pubKey);
      if (!result.success) {
        throw new Error(result.error || 'Failed to fetch balances');
      }

      setWalletBalances(result.balances);
      setBalance(result.balances.LLTY);

      console.log('âœ… Balances fetched:', result.balances);

      // Cache
      try {
        const cacheData = {
          wallet: pubKey.toString(),
          balances: result.balances,
          lastUpdate: result.timestamp,
          version: '2.0'
        };
        localStorage.setItem('llty_balance_cache', JSON.stringify(cacheData));
      } catch (cacheErr) {
        console.warn('Cache save failed:', cacheErr.message);
      }

      // Fetch purchased from DB
      try {
        const { data: userPurchases } = await dbHelpers.getUserPurchases(pubKey.toString());
        if (userPurchases && userPurchases.length > 0) {
          const totalPurchased = userPurchases.reduce((sum, p) => sum + parseFloat(p.tokens_purchased || 0), 0);
          setPurchased(totalPurchased);
        } else {
          setPurchased(result.balances.LLTY);
        }
      } catch (dbErr) {
        console.warn('Database fetch failed:', dbErr.message);
        setPurchased(result.balances.LLTY);
      }

    } catch (error) {
      console.error('âŒ fetchBalances error:', error);
      showNotification(
        'error',
        lang === 'ar'
          ? 'ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ø±ØµØ¯Ø©'
          : 'Failed to fetch balances'
      );
    } finally {
      if (showLoadingIndicator) {
        setLoading(false);
        setBalancesLoading(false);
      }
    }
  };

  const calculateTokenAmount = () => {
    if (!amount || parseFloat(amount) <= 0) return '0';
    const price = isVipPeriod ? PHASE_PRICES_DISPLAY.vip : (PHASE_PRICES_DISPLAY[currentPhase] || PHASE_PRICES_DISPLAY[1]);
    let usdValue = parseFloat(amount);
    if (currency === 'SOL' && solPrice > 0) {
      usdValue = parseFloat(amount) * solPrice;
    }
    const baseTokens = usdValue / price;
    let bonusPercentage = 0;
    if (usdValue >= 10000) bonusPercentage = 15;
    else if (usdValue >= 5000) bonusPercentage = 10;
    else if (usdValue >= 1000) bonusPercentage = 5;
    const bonusTokens = (baseTokens * bonusPercentage) / 100;
    const totalTokens = baseTokens + bonusTokens;
      console.log('ğŸ’° Token calculation:', { usdValue, price, baseTokens, bonusPercentage, bonusTokens, totalTokens, totalTokensWithDecimals: totalTokens * 1e9 });
    return totalTokens.toFixed(2);
  };

  const tokenAmount = useMemo(() => calculateTokenAmount(), [amount, currency, solPrice, isVipPeriod, currentPhase]);
  const getBonusPercentage = () => {
    if (!amount || parseFloat(amount) <= 0) return 0;
    let usdValue = parseFloat(amount);
    if (currency === 'SOL' && solPrice > 0) {
      usdValue = parseFloat(amount) * solPrice;
    }
    if (usdValue >= 10000) return 15;
    if (usdValue >= 5000) return 10;
    if (usdValue >= 1000) return 5;
    return 0;
  };

  const handleDisconnect = async () => {
    try {
      await disconnect();
      showNotification('success', lang === 'ar' ? 'ØªÙ… ÙØµÙ„ Ø§Ù„Ù…Ø­ÙØ¸Ø© Ø¨Ù†Ø¬Ø§Ø­' : 'Wallet disconnected successfully');
    } catch (error) {
      console.error('Disconnect failed:', error);
      showNotification('error', lang === 'ar' ? 'ÙØ´Ù„ ÙØµÙ„ Ø§Ù„Ù…Ø­ÙØ¸Ø©' : 'Failed to disconnect wallet');
    }
  };

  const buyTokens = async () => {
    if (!isConnected || !address) {
      showNotification('error', lang === 'ar' ? 'Ø§Ù„Ù…Ø­ÙØ¸Ø© ØºÙŠØ± Ù…ØªØµÙ„Ø©' : 'Wallet not connected');
      return;
    }

    const amt = parseFloat(amount);
    if (!amt || amt <= 0 || isNaN(amt)) {
      showNotification('error', lang === 'ar' ? 'Ø§Ù„Ù…Ø¨Ù„Øº ØºÙŠØ± ØµØ­ÙŠØ­' : 'Invalid amount');
      return;
    }

    if (isVipPeriod && amt < 1000) {
      showNotification('error', lang === 'ar' ? 'Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù€ VIP: $1,000' : 'VIP minimum: $1,000');
      return;
    }

    if (presaleEnded) {
      showNotification('error', lang === 'ar' ? 'Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ø¨ÙŠØ¹ Ø§Ù„Ù…Ø³Ø¨Ù‚' : 'Presale has ended');
      return;
    }

    // Rate limit check
    try {
      const rateLimitCheck = await dbHelpers.checkRateLimit(address);
      if (!rateLimitCheck.allowed) {
        showNotification(
          'error',
          lang === 'ar'
            ? `ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± ${rateLimitCheck.retryAfter} Ø«Ø§Ù†ÙŠØ©`
            : `Please wait ${rateLimitCheck.retryAfter} seconds`
        );
        return;
      }
    } catch (err) {
      console.warn('Rate limit check failed:', err);
    }

    setLoading(true);
    setTxStatus('pending');

    let signature = '';
    let usdValue = amt;
    let tokensReceived = 0;
    let bonusPercentage = 0;

    try {
      // ========== CALCULATE USD VALUE ==========
      if (currency === 'SOL') {
        if (solPrice === 0) {
          showNotification('error', lang === 'ar' ? 'Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø³Ø¹Ø± SOL...' : 'Loading SOL price...');
          await fetchSolPrice();
          if (solPrice === 0) {
            throw new Error(lang === 'ar' ? 'ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø³Ø¹Ø± SOL' : 'Failed to load SOL price');
          }
        }
        usdValue = amt * solPrice;
      }

      // ========== CALCULATE TOKENS AND BONUS ==========
      const price = isVipPeriod ? PHASE_PRICES_DISPLAY.vip : PHASE_PRICES_DISPLAY[currentPhase];
      const baseTokens = usdValue / price;
      bonusPercentage = calculateBonus(usdValue);
      const bonusTokens = (baseTokens * bonusPercentage) / 100;
      const totalTokens = baseTokens + bonusTokens;

      // ========== CHECK BALANCE ==========
      const currentBalance = walletBalances[currency];
      const requiredBalance = currency === 'SOL' ? amt + 0.01 : amt;

      if (currentBalance < requiredBalance) {
        showNotification(
          'error',
          lang === 'ar'
            ? `Ø±ØµÙŠØ¯ ${currency} ØºÙŠØ± ÙƒØ§ÙÙ`
            : `Insufficient ${currency} balance`,
          8000
        );
        return;
      }

      // ========== BUILD TRANSACTION ==========
      showNotification('info', lang === 'ar' ? 'Ø¬Ø§Ø±ÙŠ Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©...' : 'Building transaction...');

      const userPubkey = new PublicKey(address);
      const conn = new Connection(BLOCKCHAIN_CONFIG.rpcEndpoint, 'confirmed');

      let result;

      if (currency === 'SOL') {
        console.log('ğŸŸ£ Building SOL purchase transaction...');
        result = await purchaseService.buildSOLPurchaseTransaction({
          userPublicKey: userPubkey,
          amount: totalTokens,
          currency: 'SOL',
          connection: conn,
        });
      } else if (currency === 'USDC') {
        console.log('ğŸ”µ Building USDC purchase transaction...');
        result = await purchaseService.buildUSDCPurchaseTransaction({
          userPublicKey: userPubkey,
          amount: totalTokens,
          currency: 'USDC',
          connection: conn,
        });
      } else if (currency === 'USDT') {
        console.log('ğŸŸ¢ Building USDT purchase transaction...');
        result = await purchaseService.buildUSDTPurchaseTransaction({
          userPublicKey: userPubkey,
          amount: totalTokens,
          currency: 'USDT',
          connection: conn,
        });
      }

      if (!result?.transaction) {
        throw new Error('Failed to build transaction');
      }

      const { transaction } = result;

      console.log('âœ… Transaction built successfully');
      console.log('Amount:', amt, currency, 'â†’', totalTokens.toLocaleString(), 'LLTY tokens');

      // ========== SIGN AND SEND TRANSACTION - âœ… FIXED VERSION ==========
      showNotification('info', lang === 'ar' ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙˆÙ‚ÙŠØ¹ ÙˆØ§Ù„Ø¥Ø±Ø³Ø§Ù„...' : 'Signing and sending...');

      console.log('ğŸ” Getting wallet provider...');
      console.log('ğŸ“Š walletProvider from hook:', walletProvider);
      console.log('ğŸ“Š window.solana:', typeof window !== 'undefined' ? window.solana : 'undefined');

      // âœ… Get wallet provider - Multiple fallback methods
      let provider = null;

      // Method 1: Use walletProvider from useAppKitProvider hook
      if (walletProvider) {
        provider = walletProvider;
        console.log('âœ… Method 1: Got wallet provider from useAppKitProvider hook');
      }
      
      // Method 2: Try window.solana (for direct wallet extensions)
      if (!provider && typeof window !== 'undefined' && window.solana) {
        provider = window.solana;
        console.log('âœ… Method 2: Got wallet provider from window.solana');
      }

      // Validate provider
      if (!provider) {
        throw new Error('Wallet provider not available. Please reconnect your wallet.');
      }

      if (typeof provider.signTransaction !== 'function') {
        console.error('Provider object:', provider);
        throw new Error('Wallet does not support transaction signing.');
      }

      console.log('âœ… Wallet provider ready');
      console.log('ğŸ“Š Provider details:', {
        hasSignTransaction: typeof provider.signTransaction === 'function',
        publicKey: provider.publicKey?.toString() || 'unknown',
        isConnected: provider.isConnected || false
      });

      // Sign transaction
      console.log('ğŸ“ Requesting signature from wallet...');
      const signedTx = await provider.signTransaction(transaction);

      if (!signedTx || !signedTx.serialize) {
        throw new Error('Transaction signing failed - invalid signed transaction');
      }

      // Send transaction
      console.log('ğŸ“¤ Sending transaction...');
      signature = await conn.sendRawTransaction(signedTx.serialize(), {
        skipPreflight: false,
        preflightCommitment: 'confirmed',
        maxRetries: 3,
      });

      console.log(`ğŸ”— Transaction signature: ${signature}`);

      // Confirm transaction
      console.log('â³ Confirming transaction...');
      const confirmation = await conn.confirmTransaction(signature, 'confirmed');

      if (confirmation.value.err) {
        throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);
      }

      console.log('âœ… Transaction confirmed successfully!');
      setTxSignature(signature);
      setTxStatus('confirmed');
      tokensReceived = totalTokens;

      // ========== DATABASE RECORDING ==========
      try {
        const { data: dbRecord, error: dbError } = await dbHelpers.recordPurchase({
          walletAddress: address,
          tokensPurchased: tokensReceived,
          usdAmount: usdValue,
          currency: currency,
          bonusPercentage,
          signature,
          phase: currentPhase,
          isVip: isVipPeriod
        });

        if (dbError) {
          console.error('Database error:', dbError);
        } else {
          console.log('âœ… Purchase recorded:', dbRecord);
          setTimeout(async () => {
            await dbHelpers.markVerified(signature);
          }, 5000);
        }
      } catch (dbErr) {
        console.error('Database exception:', dbErr);
      }

      // ========== UPDATE LOCAL STATE ==========
      const stored = localStorage.getItem('llty_wallet');
      const dataStored = stored ? JSON.parse(stored) : { address, purchased: 0 };
      dataStored.purchased = (dataStored.purchased || 0) + tokensReceived;
      dataStored.lastPurchase = Date.now();
      dataStored.lastSignature = signature;
      localStorage.setItem('llty_wallet', JSON.stringify(dataStored));
      setPurchased(dataStored.purchased);

      const totalData = localStorage.getItem('llty_total_raised');
      const currentTotal = totalData ? JSON.parse(totalData) : { raised: 0, sold: 0 };
      currentTotal.raised += usdValue;
      currentTotal.sold += tokensReceived;
      localStorage.setItem('llty_total_raised', JSON.stringify(currentTotal));
      setTotalRaised(currentTotal.raised);
      setTotalLLTYSold(currentTotal.sold);

      if (isVipPeriod) {
        const vipData = localStorage.getItem('llty_vip_count');
        const currentVipCount = vipData ? parseInt(vipData) : 0;
        const newVipCount = Math.min(currentVipCount + 1, 50);
        localStorage.setItem('llty_vip_count', newVipCount.toString());
        setVipBuyersCount(newVipCount);
      }

      setAmount('');
      setCalculatedTokens(0);
      setBonusPercentage(0);
      await fetchBalances();

      showNotification(
        'success',
        `${lang === 'ar' ? 'Ù†Ø¬Ø­ Ø§Ù„Ø´Ø±Ø§Ø¡!' : 'Purchase successful!'} ${tokensReceived.toLocaleString()} LLTY${bonusPercentage > 0 ? ` (+${bonusPercentage}% bonus)` : ''}`
      );

      setTimeout(() => {
        showNotification(
          'info',
          `${lang === 'ar' ? 'Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©' : 'View transaction'}: https://explorer.solana.com/tx/${signature}?cluster=${NETWORK}`
        );
      }, 2000);

    } catch (err) {
      console.error('âŒ Buy tokens error:', err);
      setTxStatus('failed');

      let errorMessage = err.message || 'Unknown error';
      if (errorMessage.includes('User rejected')) {
        errorMessage = lang === 'ar' ? 'ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©' : 'Transaction cancelled';
      } else if (errorMessage.includes('Insufficient')) {
        errorMessage = lang === 'ar' ? 'Ø±ØµÙŠØ¯ ØºÙŠØ± ÙƒØ§ÙÙ' : errorMessage;
      } else if (errorMessage.includes('Wallet provider not available')) {
        errorMessage = lang === 'ar' ? 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆØµÙŠÙ„ Ø§Ù„Ù…Ø­ÙØ¸Ø©' : 'Please reconnect your wallet';
      }
      showNotification('error', `${lang === 'ar' ? 'Ø®Ø·Ø£' : 'Error'}: ${errorMessage}`);
    } finally {
      setLoading(false);
    }
  };

  const fetchPresaleData = async (conn) => {
    try {
      const totalData = localStorage.getItem('llty_total_raised');
      if (totalData) {
        const data = JSON.parse(totalData);
        setTotalRaised(data.raised || 0);
        setTotalLLTYSold(data.sold || 0);
      }
    } catch (err) {
      console.error('Failed to fetch presale data:', err);
    }
  };

  const fetchSolPrice = async () => {
    try {
      const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd');
      const data = await response.json();
      setSolPrice(data.solana?.usd || 150);
    } catch (err) {
      setSolPrice(150);
    }
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // EFFECTS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Auto-connect & localStorage restore
  // Clear cache when wallet changes
  useEffect(() => {
    if (address) {
      blockchainService.clearCache();
      fetchBalances();
    }
  }, [address]);

    const stored = localStorage.getItem('llty_wallet');
  useEffect(() => {
    if (stored && isConnected && address) {
      try {
        const data = JSON.parse(stored);
        const timeSinceConnect = Date.now() - (data.lastConnected || 0);
        const oneDayInMs = 24 * 60 * 60 * 1000;
        if (timeSinceConnect < oneDayInMs && data.address === address) {
          fetchBalances();
        } else {
          localStorage.removeItem('llty_wallet');
        }
      } catch (err) {
        console.error('Failed to restore wallet data:', err);
        localStorage.removeItem('llty_wallet');
      }
    }
  }, [isConnected, address]);

  // Save to localStorage when connected
  useEffect(() => {
    if (isConnected && address) {
      const walletData = {
        address,
        walletType: 'Reown',
        purchased: purchased,
        lastConnected: Date.now()
      };
      localStorage.setItem('llty_wallet', JSON.stringify(walletData));
    }
  }, [isConnected, address, purchased]);


  // City carousel
  useEffect(() => {
    const interval = setInterval(() => {
      setCurrentCityIndex((prev) => (prev + 1) % citiesData.length);
    }, 5000);
    return () => clearInterval(interval);
  }, []);

  // Initialize
  useEffect(() => {
    const conn = new Connection(RPC_ENDPOINT, 'confirmed');
    fetchSolPrice();
    fetchPresaleData(conn);
  }, []);

  // Debounced buy function
  const buyTokensDebounced = useCallback(
    debounce(buyTokens, 2000, { leading: true, trailing: false }),
    [buyTokens]
  );

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // RENDER
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  return (
    <div className={`min-h-screen ${lang === 'ar' ? 'rtl' : 'ltr'} font-sans`}
      style={{
        background: 'linear-gradient(to bottom, #0f172a 0%, #1e293b 50%, #334155 100%)',
        color: '#f1f5f9'
      }}>

      {/* Notification */}
      {notification.show && (
        <div className="fixed top-24 right-4 z-50 animate-slide-in-right">
          <div className={`flex items-center gap-3 px-6 py-4 rounded-lg shadow-2xl border ${
            notification.type === 'success' ? 'bg-green-900/90 border-green-500' :
            notification.type === 'error' ? 'bg-red-900/90 border-red-500' :
            'bg-blue-900/90 border-blue-500'
          }`}>
            {notification.type === 'success' ? <CheckCircle className="text-green-400" size={24} /> :
             notification.type === 'error' ? <AlertCircle className="text-red-400" size={24} /> :
             <Clock className="text-blue-400" size={24} />}
            <span className="font-medium text-white">{notification.message}</span>
          </div>
        </div>
      )}

      <Header
        lang={lang}
        setLang={setLang}
        t={t}
        isConnected={isConnected}
        address={address}
        balance={balance}
        menuOpen={menuOpen}
        setMenuOpen={setMenuOpen}
        loading={loading}
        open={open}
        handleDisconnect={handleDisconnect}
        scrollToSection={scrollToSection}
        shortenAddress={shortenAddress}
      />

      <main className="container mx-auto px-4 py-8">
        <HeroSection
          lang={lang}
          t={t}
          isVipPeriod={isVipPeriod}
          currentPhase={currentPhase}
          presaleEnded={presaleEnded}
          phaseTimeRemaining={phaseTimeRemaining}
          getUrgencyMessage={getUrgencyMessage}
          totalRaised={totalRaised}
          totalLLTYSold={totalLLTYSold}
          PRESALE_TARGET={PRESALE_TARGET}
          PHASE_PRICES_DISPLAY={PHASE_PRICES_DISPLAY}
          progressPercentage={progressPercentage}
        />

        <VIPSection
          lang={lang}
          t={t}
          isVipPeriod={isVipPeriod}
          vipBuyersCount={vipBuyersCount}
          scrollToSection={scrollToSection}
        />

        <BonusTiersSection
          lang={lang}
          t={t}
        />

        <ReferralSection
          lang={lang}
          t={t}
          isConnected={isConnected}
          address={address}
          showNotification={showNotification}
        />

        <BuySection
          lang={lang}
          t={t}
          isConnected={isConnected}
          address={address}
          isVipPeriod={isVipPeriod}
          loading={loading}
          amount={amount}
          setAmount={setAmount}
          currency={currency}
          setCurrency={setCurrency}
          walletBalances={walletBalances}
          tokenAmount={tokenAmount}
          getBonusPercentage={getBonusPercentage}
          buyTokensDebounced={buyTokensDebounced}
          purchased={purchased}
          open={open}
        />

        {/* STAKING SECTION */}
        <StakingSection
          lang={lang}
          isConnected={isConnected}
          walletAddress={address}
          stakingData={stakingData}
          showNotification={showNotification}
        />

        {/* GOVERNANCE SECTION */}
        <GovernanceSection
          lang={lang}
          isConnected={isConnected}
          walletAddress={address}
          governanceData={governanceData}
          showNotification={showNotification}
        />

        <AboutSection
          lang={lang}
          t={t}
          scrollToSection={scrollToSection}
        />

        <CitiesSection
          lang={lang}
          t={t}
          citiesData={citiesData}
          currentCityIndex={currentCityIndex}
          setCurrentCityIndex={setCurrentCityIndex}
        />

        <TokenomicsSection
          lang={lang}
          t={t}
        />

        <RoadmapSection
          lang={lang}
          t={t}
          roadmapData={roadmapData}
        />

        <SecuritySection
          lang={lang}
          t={t}
        />
      </main>

        <Footer lang={lang} />
    </div>
  );
};

export default App;
