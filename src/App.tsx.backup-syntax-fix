// ============================================================================
// LLTY PRESALE - COMPLETE APP WITH ALL BUSINESS LOGIC + STAKING + GOVERNANCE
// Professional hybrid architecture: centralized logic, modular UI components
// ============================================================================

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { useAppKit, useAppKitAccount } from '@reown/appkit/react';
import {
  Connection,
  PublicKey,
  Transaction,
  VersionedTransaction,
  SystemProgram,
  LAMPORTS_PER_SOL,
  TransactionInstruction
} from '@solana/web3.js';
import {
  TOKEN_PROGRAM_ID,
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction
} from '@solana/spl-token';
import { BN } from '@coral-xyz/anchor';
import { debounce } from 'lodash';
import { createJupiterApiClient } from '@jup-ag/api';
import { CheckCircle, AlertCircle, Clock } from 'lucide-react';

// Services & Libraries
import blockchainService from './services/blockchainService';
import stakingService from './services/stakingService';
import governanceService from './services/governanceService';
import { supabase, dbHelpers } from './lib/supabase';
import { captureError, captureMessage } from './lib/sentry';

// Hooks
import { useStaking } from './hooks/useStaking';
import { useGovernance } from './hooks/useGovernance';

// Components
import Header from './components/layout/Header';
import Footer from './components/layout/Footer';
import HeroSection from './components/sections/HeroSection';
import VIPSection from './components/sections/VIPSection';
import BonusTiersSection from './components/sections/BonusTiersSection';
import ReferralSection from './components/sections/ReferralSection';
import BuySection from './components/presale/BuySection';
import TokenomicsSection from './components/sections/TokenomicsSection';
import RoadmapSection from './components/sections/RoadmapSection';
import AboutSection from './components/sections/AboutSection';
import CitiesSection from './components/sections/CitiesSection';
import SecuritySection from './components/sections/SecuritySection';
import StakingSection from './components/sections/StakingSection';
import GovernanceSection from './components/sections/GovernanceSection';
import LLTYLogo from './components/LLTYLogo.jsx';
// Translations
import { translations } from './i18n/translations';

// ============================================================================
// CONSTANTS & CONFIGURATION
// ============================================================================
const NETWORK = 'devnet';
const RPC_ENDPOINT = 'https://api.devnet.solana.com';

const ADDRESSES = {
  PROGRAM_ID: new PublicKey('2oArywYY7xHyoV1xoF9g9QKkyKDHe3rA9kRyu1H8ZQxo'),
  LLTY_MINT: new PublicKey('6UYrC72Xseu8bSrjZz5VUZ3aGo68MEqpNNyMgqqcfajf'),
  USDC_MINT: new PublicKey('7e54j2gSb31gpeW3sLZktexZBqrA1tLzg14ncuiphrP4'),
  USDT_MINT: new PublicKey('Gh9ZwEmdLJ8DscKNTkTqPbNwLNNBjuwSzGqKzNNc98FK'),
  PRESALE_PDA: new PublicKey('9b55xaKqELt1fYHn6MXA9vETy4ngTPxSZZ1SJmTQN1Kr'),
  LLTY_VAULT: new PublicKey('9UqwUfRpi41GBTVuHPiSjWXUoW4EoWah3aYdiUspfU7f'),
  USDC_VAULT: new PublicKey('Hzmv4eWhLFbfC7XpDmf3dpMCn6jHDXDSYWosv87Nmegh'),
  USDT_VAULT: new PublicKey('EfHXwphpyAkeGrogUEGPQVSiPwXQDvpaFZvwJBbkmB9k')
};

const PRESALE_START = new Date('2026-01-01T00:00:00Z').getTime();
const VIP_DURATION = 2 * 24 * 60 * 60 * 1000;
const PUBLIC_START = PRESALE_START + VIP_DURATION;
const PRESALE_END = new Date('2026-02-11T23:59:59Z').getTime();
const PHASE_DURATION = 14 * 24 * 60 * 60 * 1000;

const PHASE_PRICES_DISPLAY = {
  vip: 0.001,
  1: 0.004,
  2: 0.005,
  3: 0.006
};

const PHASE_ALLOCATIONS = {
  1: 1_000_000_000,
  2: 1_500_000_000,
  3: 1_500_000_000
};

const PRESALE_TARGET = (
  (PHASE_ALLOCATIONS[1] * PHASE_PRICES_DISPLAY[1]) +
  (PHASE_ALLOCATIONS[2] * PHASE_PRICES_DISPLAY[2]) +
  (PHASE_ALLOCATIONS[3] * PHASE_PRICES_DISPLAY[3])
);

const citiesData = [
  { name: 'Amman, Jordan', image: 'https://images.unsplash.com/photo-1578894381163-e72c17f2d45f?w=800' },
  { name: 'Dubai, UAE', image: 'https://images.unsplash.com/photo-1512453979798-5ea266f8880c?w=800' },
  { name: 'Abu Dhabi, UAE', image: 'https://images.unsplash.com/photo-1512632578888-169bbbc64f33?w=800' },
  { name: 'Riyadh, Saudi Arabia', image: 'https://images.unsplash.com/photo-1591608971362-f08b2a75731a?w=800' },
  { name: 'Jeddah, Saudi Arabia', image: 'https://images.unsplash.com/photo-1586724237569-f3d0c1dee8c6?w=800' },
  { name: 'Cairo, Egypt', image: 'https://images.unsplash.com/photo-1539768942893-daf53e448371?w=800' },
  { name: 'Beirut, Lebanon', image: 'https://images.unsplash.com/photo-1580922090158-85e89c1d9c9e?w=800' },
  { name: 'Doha, Qatar', image: 'https://images.unsplash.com/photo-1574164047321-cc3a85cc5e6d?w=800' },
  { name: 'Kuwait City, Kuwait', image: 'https://images.unsplash.com/photo-1577699113768-7a5e25863083?w=800' },
];

// ============================================================================
// MAIN APP COMPONENT
// ============================================================================
const App = () => {
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // WALLET & CONNECTION
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const fallbackConnection = useMemo(() => new Connection(RPC_ENDPOINT, 'confirmed'), []);
  const { open } = useAppKit();
  const { address, isConnected } = useAppKitAccount();
  const connection = useMemo(() => new Connection(RPC_ENDPOINT, 'confirmed'), []);
  const { walletProvider, disconnect } = useAppKit();

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // CUSTOM HOOKS - STAKING & GOVERNANCE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const stakingData = useStaking(address, connection);
  const governanceData = useGovernance(address, connection);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STATE: BALANCES
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const [balance, setBalance] = useState(0);
  const [walletBalances, setWalletBalances] = useState({
    SOL: 0,
    USDC: 0,
    USDT: 0
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STATE: TRANSACTION
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const [loading, setLoading] = useState(false);
  const [txSignature, setTxSignature] = useState('');
  const [txStatus, setTxStatus] = useState('');
  const [balancesLoading, setBalancesLoading] = useState(false);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STATE: PURCHASE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const [amount, setAmount] = useState('');
  const [currency, setCurrency] = useState('USDC');
  const [calculatedTokens, setCalculatedTokens] = useState(0);
  const [bonusPercentage, setBonusPercentage] = useState(0);
  const [purchased, setPurchased] = useState(0);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STATE: UI
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const [lang, setLang] = useState('ar');
  const [menuOpen, setMenuOpen] = useState(false);
  const [notification, setNotification] = useState({
    show: false,
    type: '',
    message: ''
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STATE: PRESALE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const [currentPhase, setCurrentPhase] = useState(1);
  const [isVipPeriod, setIsVipPeriod] = useState(false);
  const [vipBuyersCount, setVipBuyersCount] = useState(0);
  const [presaleEnded, setPresaleEnded] = useState(false);
  const [phaseTimeRemaining, setPhaseTimeRemaining] = useState({
    days: 0,
    hours: 0,
    minutes: 0,
    seconds: 0
  });
  const [totalRaised, setTotalRaised] = useState(0);
  const [totalLLTYSold, setTotalLLTYSold] = useState(0);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STATE: CAROUSEL & PRICING
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const [currentCityIndex, setCurrentCityIndex] = useState(0);
  const [solPrice, setSolPrice] = useState(0);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // COMPUTED VALUES
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const t = translations[lang];
  
  const roadmapData = [
    {
      quarter: translations[lang].navigation.q1_2026,
      title: translations[lang].navigation.presale_launch,
      desc: translations[lang].navigation.presale_launch_desc,
    },
    {
      quarter: translations[lang].navigation.q2_2026,
      title: translations[lang].navigation.smart_contract_audit,
      desc: translations[lang].navigation.smart_contract_audit_desc,
    },
    {
      quarter: translations[lang].navigation.q3_2026,
      title: translations[lang].navigation.mainnet_launch,
      desc: translations[lang].navigation.mainnet_launch_desc,
    },
    {
      quarter: translations[lang].navigation.q4_2026,
      title: translations[lang].navigation.first_property,
      desc: translations[lang].navigation.first_property_desc,
    },
    {
      quarter: translations[lang].navigation.q1_2027,
      title: translations[lang].navigation.dex_listing,
      desc: translations[lang].navigation.dex_listing_desc,
    },
    {
      quarter: translations[lang].navigation.q2_2027,
      title: translations[lang].navigation.expansion_5_cities,
      desc: translations[lang].navigation.expansion_5_cities_desc,
    },
    {
      quarter: translations[lang].navigation.q3_2027,
      title: translations[lang].navigation.mobile_app,
      desc: translations[lang].navigation.mobile_app_desc,
    },
    {
      quarter: translations[lang].navigation.q4_2027,
      title: translations[lang].navigation.portfolio_20_properties,
      desc: translations[lang].navigation.portfolio_20_properties_desc,
    },
  ];

  const progressPercentage = Math.min((totalRaised / PRESALE_TARGET) * 100, 100);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // UTILITY FUNCTIONS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const shortenAddress = (address) => {
    if (!address) return '';
    return `${address.slice(0, 4)}...${address.slice(-4)}`;
  };

  const scrollToSection = (id) => {
    setMenuOpen(false);
    const element = document.getElementById(id);
    if (element) {
      element.scrollIntoView({ behavior: 'smooth' });
    }
  };

  const showNotification = useCallback((type, message, duration = 5000) => {
    setNotification({ show: true, type, message });
    if (duration > 0) {
      setTimeout(() => {
        setNotification(prev => ({ ...prev, show: false }));
      }, duration);
    }
  }, []);

  const calculateBonus = (usdAmount) => {
    if (usdAmount >= 10000) return 15;
    if (usdAmount >= 5000) return 10;
    if (usdAmount >= 1000) return 5;
    return 0;
  };

  const getUrgencyMessage = () => {
    if (isVipPeriod) {
      return lang === 'ar' ? 'âš¡ ÙØªØ±Ø© VIP Ù†Ø´Ø·Ø©! ÙÙ‚Ø· 50 Ù…Ù‚Ø¹Ø¯ Ù…ØªØ§Ø­!' : 'âš¡ VIP Period Active! Only 50 Slots!';
    }
    const hoursLeft = Math.floor(phaseTimeRemaining.days * 24 + phaseTimeRemaining.hours);
    if (hoursLeft < 24) {
      return lang === 'ar' ? 'âš¡ Ø£Ù‚Ù„ Ù…Ù† 24 Ø³Ø§Ø¹Ø© Ù„Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ!' : 'âš¡ Less than 24 hours at this price!';
    }
    if (hoursLeft < 72) {
      return lang === 'ar' ? 'ğŸ”¥ Ø§Ù„Ø³Ø¹Ø± ÙŠØ±ØªÙØ¹ Ù‚Ø±ÙŠØ¨Ø§Ù‹!' : 'ğŸ”¥ Price increasing soon!';
    }
    return lang === 'ar' ? 'â° ÙˆÙ‚Øª Ù…Ø­Ø¯ÙˆØ¯ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¹Ø±' : 'â° Limited time at this price';
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // BLOCKCHAIN FUNCTIONS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const fetchBalances = async (showLoadingIndicator = true) => {
    if (!isConnected || !address) {
      console.warn('Cannot fetch balances: not connected');
      return;
    }

    if (showLoadingIndicator) {
      setLoading(true);
      setBalancesLoading(true);
    }

    try {
      const pubKey = new PublicKey(address);
      console.log('ğŸ” Fetching balances from blockchain...');

      const result = await blockchainService.fetchAllBalances(pubKey);
      if (!result.success) {
        throw new Error(result.error || 'Failed to fetch balances');
      }

      setWalletBalances(result.balances);
      setBalance(result.balances.LLTY);

      console.log('âœ… Balances fetched:', result.balances);

      // Cache
      try {
        const cacheData = {
          wallet: pubKey.toString(),
          balances: result.balances,
          lastUpdate: result.timestamp,
          version: '2.0'
        };
        localStorage.setItem('llty_balance_cache', JSON.stringify(cacheData));
      } catch (cacheErr) {
        console.warn('Cache save failed:', cacheErr.message);
      }

      // Fetch purchased from DB
      try {
        const { data: userPurchases } = await dbHelpers.getUserPurchases(pubKey.toString());
        if (userPurchases && userPurchases.length > 0) {
          const totalPurchased = userPurchases.reduce((sum, p) => sum + parseFloat(p.tokens_purchased || 0), 0);
          setPurchased(totalPurchased);
        } else {
          setPurchased(result.balances.LLTY);
        }
      } catch (dbErr) {
        console.warn('Database fetch failed:', dbErr.message);
        setPurchased(result.balances.LLTY);
      }

    } catch (error) {
      console.error('âŒ fetchBalances error:', error);
      showNotification(
        'error',
        lang === 'ar'
          ? 'ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ø±ØµØ¯Ø©'
          : 'Failed to fetch balances'
      );
    } finally {
      if (showLoadingIndicator) {
        setLoading(false);
        setBalancesLoading(false);
      }
    }
  };

  const calculateTokenAmount = () => {
    if (!amount || parseFloat(amount) <= 0) return '0';
    const price = isVipPeriod ? PHASE_PRICES_DISPLAY.vip : (PHASE_PRICES_DISPLAY[currentPhase] || PHASE_PRICES_DISPLAY[1]);
    let usdValue = parseFloat(amount);
    if (currency === 'SOL' && solPrice > 0) {
      usdValue = parseFloat(amount) * solPrice;
    }
    const baseTokens = usdValue / price;
    let bonusPercentage = 0;
    if (usdValue >= 10000) bonusPercentage = 15;
    else if (usdValue >= 5000) bonusPercentage = 10;
    else if (usdValue >= 1000) bonusPercentage = 5;
    const bonusTokens = (baseTokens * bonusPercentage) / 100;
    const totalTokens = baseTokens + bonusTokens;
    return totalTokens.toFixed(2);
  };

  const getBonusPercentage = () => {
    if (!amount || parseFloat(amount) <= 0) return 0;
    let usdValue = parseFloat(amount);
    if (currency === 'SOL' && solPrice > 0) {
      usdValue = parseFloat(amount) * solPrice;
    }
    if (usdValue >= 10000) return 15;
    if (usdValue >= 5000) return 10;
    if (usdValue >= 1000) return 5;
    return 0;
  };

  const swapToUSDC = async (inputMint, inputAmount) => {
    try {
      showNotification('info', t.swapping);

      const amountInSmallestUnit = inputMint.equals(new PublicKey('So11111111111111111111111111111111111111112'))
        ? Math.floor(inputAmount * LAMPORTS_PER_SOL)
        : Math.floor(inputAmount * 1e6);

      const jupiterQuoteApi = createJupiterApiClient({
        basePath: 'https://quote-api.jup.ag/v4'
      });

      showNotification('info', lang === 'ar' ? 'Ø¬Ø§Ø±ÙŠ Ø­Ø³Ø§Ø¨ Ø£ÙØ¶Ù„ Ø³Ø¹Ø±...' : 'Computing best price...');

      const quote = await jupiterQuoteApi.quoteGet({
        inputMint: inputMint.toString(),
        outputMint: ADDRESSES.USDC_MINT.toString(),
        amount: amountInSmallestUnit.toString(),
        slippageBps: 100,
        onlyDirectRoutes: false,
        asLegacyTransaction: false,
      });

      if (!quote) {
        throw new Error(lang === 'ar' ? 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø³Ø¹Ø± Ù„Ù„ØªØ¨Ø¯ÙŠÙ„' : 'No swap quote found');
      }

      if (quote.priceImpactPct && parseFloat(quote.priceImpactPct) > 2) {
        showNotification(
          'warning',
          lang === 'ar'
            ? `âš ï¸ ØªØ£Ø«ÙŠØ± Ø§Ù„Ø³Ø¹Ø±: ${parseFloat(quote.priceImpactPct).toFixed(2)}%`
            : `âš ï¸ Price impact: ${parseFloat(quote.priceImpactPct).toFixed(2)}%`,
          3000
        );
      }

      showNotification('info', lang === 'ar' ? 'Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©...' : 'Creating transaction...');

      const swapResult = await jupiterQuoteApi.swapPost({
        swapRequest: {
          quoteResponse: quote,
          userPublicKey: address,
          wrapAndUnwrapSol: true,
          dynamicComputeUnitLimit: true,
          prioritizationFeeLamports: {
            autoMultiplier: 2
          },
        },
      });

      if (!swapResult || !swapResult.swapTransaction) {
        throw new Error(lang === 'ar' ? 'ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¹Ø§Ù…Ù„Ø© Ø§Ù„ØªØ¨Ø¯ÙŠÙ„' : 'Failed to create swap transaction');
      }

      showNotification('info', lang === 'ar' ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙˆÙ‚ÙŠØ¹ ÙˆØ§Ù„Ø¥Ø±Ø³Ø§Ù„...' : 'Signing and sending...');

      const swapTransactionBuf = Buffer.from(swapResult.swapTransaction, 'base64');
      const transaction = VersionedTransaction.deserialize(swapTransactionBuf);

      const provider = await walletProvider;
      if (!provider) {
        throw new Error('Wallet provider not available');
      }

      const { signature } = await provider.signAndSendTransaction(transaction);
      
      showNotification('info', lang === 'ar' ? 'Ø¬Ø§Ø±ÙŠ ØªØ£ÙƒÙŠØ¯ Ø§Ù„ØªØ¨Ø¯ÙŠÙ„...' : 'Confirming swap...');

      const effectiveConnection = connection || fallbackConnection;
      await effectiveConnection.confirmTransaction(signature, 'confirmed');

      const usdcReceived = parseFloat(quote.outAmount) / 1e6;

      showNotification('success', `${t.swapSuccess}: ${usdcReceived.toFixed(2)} USDC`, 4000);

      await new Promise(resolve => setTimeout(resolve, 2000));

      return usdcReceived;

    } catch (err) {
      console.error('âŒ Jupiter swap error:', err);

      let errorMessage = err.message || 'Unknown error';

      if (errorMessage.includes('User rejected') || errorMessage.includes('User cancelled')) {
        errorMessage = lang === 'ar' ? 'ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ¨Ø¯ÙŠÙ„' : 'Swap cancelled';
      } else if (errorMessage.includes('No swap quote') || errorMessage.includes('No routes')) {
        errorMessage = lang === 'ar'
          ? 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø³Ø§Ø± Ù„Ù„ØªØ¨Ø¯ÙŠÙ„. Ø­Ø§ÙˆÙ„ Ù…Ø¨Ù„Øº Ù…Ø®ØªÙ„Ù.'
          : 'No swap route found. Try a different amount.';
      }

      throw new Error(errorMessage);
    }
  };

  const handleDisconnect = async () => {
    try {
      await disconnect();
      showNotification('success', lang === 'ar' ? 'ØªÙ… ÙØµÙ„ Ø§Ù„Ù…Ø­ÙØ¸Ø© Ø¨Ù†Ø¬Ø§Ø­' : 'Wallet disconnected successfully');
    } catch (error) {
      console.error('Disconnect failed:', error);
      showNotification('error', lang === 'ar' ? 'ÙØ´Ù„ ÙØµÙ„ Ø§Ù„Ù…Ø­ÙØ¸Ø©' : 'Failed to disconnect wallet');
    }
  };

  const buyTokens = async () => {
    if (!isConnected || !address) {
      showNotification('error', lang === 'ar' ? 'Ø§Ù„Ù…Ø­ÙØ¸Ø© ØºÙŠØ± Ù…ØªØµÙ„Ø©' : 'Wallet not connected');
      return;
    }

    const amt = parseFloat(amount);
    if (!amt || amt <= 0 || isNaN(amt)) {
      showNotification('error', lang === 'ar' ? 'Ø§Ù„Ù…Ø¨Ù„Øº ØºÙŠØ± ØµØ­ÙŠØ­' : 'Invalid amount');
      return;
    }

    if (isVipPeriod && amt < 1000) {
      showNotification('error', lang === 'ar' ? 'Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù€ VIP: $1,000' : 'VIP minimum: $1,000');
      return;
    }

    if (presaleEnded) {
      showNotification('error', lang === 'ar' ? 'Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ø¨ÙŠØ¹ Ø§Ù„Ù…Ø³Ø¨Ù‚' : 'Presale has ended');
      return;
    }

    try {
      const rateLimitCheck = await dbHelpers.checkRateLimit(address);
      if (!rateLimitCheck.allowed) {
        showNotification(
          'error',
          lang === 'ar'
            ? `ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± ${rateLimitCheck.retryAfter} Ø«Ø§Ù†ÙŠØ©`
            : `Please wait ${rateLimitCheck.retryAfter} seconds`
        );
        return;
      }
    } catch (err) {
      console.warn('Rate limit check failed:', err);
    }

    setLoading(true);
    setTxStatus('pending');

    let signature = '';
    let usdValue = amt;
    let tokensReceived = 0;
    let bonusPercentage = 0;

    try {
      // Handle SOL currency
      if (currency === 'SOL') {
        if (solPrice === 0) {
          showNotification('error', lang === 'ar' ? 'Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø³Ø¹Ø± SOL...' : 'Loading SOL price...');
          await fetchSolPrice();
          if (solPrice === 0) {
            throw new Error(lang === 'ar' ? 'ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø³Ø¹Ø± SOL' : 'Failed to load SOL price');
          }
        }

        usdValue = amt * solPrice;

        const currentSOLBalance = walletBalances.SOL;
        const requiredSOL = amt + 0.01;

        if (currentSOLBalance < requiredSOL) {
          showNotification(
            'error',
            lang === 'ar'
              ? `Ø±ØµÙŠØ¯ SOL ØºÙŠØ± ÙƒØ§ÙÙ. ØªØ­ØªØ§Ø¬ ${requiredSOL.toFixed(4)} SOL`
              : `Insufficient SOL. Need ${requiredSOL.toFixed(4)} SOL`,
            8000
          );
          return;
        }

        if (amt < 0.5) {
          showNotification(
            'error',
            lang === 'ar' ? 'Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ 0.5 SOL' : 'Minimum 0.5 SOL',
            6000
          );
          return;
        }

        try {
          showNotification('info', lang === 'ar' ? `Ø¬Ø§Ø±ÙŠ ØªØ¨Ø¯ÙŠÙ„ ${amt} SOL...` : `Swapping ${amt} SOL...`, 3000);
          const inputMint = new PublicKey('So11111111111111111111111111111111111111112');
          await swapToUSDC(inputMint, amt);
          await new Promise(resolve => setTimeout(resolve, 2000));
          await fetchBalances(false);
        } catch (swapError) {
          console.error('âŒ Swap failed:', swapError);
          showNotification('error', swapError.message, 8000);
          throw swapError;
        }
      } else {
        usdValue = amt;
      }

      // Calculate tokens and bonus
      const price = isVipPeriod ? PHASE_PRICES_DISPLAY.vip : PHASE_PRICES_DISPLAY[currentPhase];
      const baseTokens = usdValue / price;
      bonusPercentage = calculateBonus(usdValue);
      const bonusTokens = (baseTokens * bonusPercentage) / 100;
      const totalTokens = baseTokens + bonusTokens;
      const tokenAmountInSmallestUnit = Math.floor(totalTokens * 1e9);

      let finalUsdcAmount = amt;

      if (currency === 'SOL') {
        const solAta = await getAssociatedTokenAddress(
          new PublicKey('So11111111111111111111111111111111111111112'),
          new PublicKey(address)
        );
        const solAccountInfo = await connection.getAccountInfo(solAta);
        if (solAccountInfo) {
          const solTokenBalance = await connection.getTokenAccountBalance(solAta);
          finalUsdcAmount = parseFloat(solTokenBalance.value.uiAmount);
        }
      }

      // Check payment balance
      const paymentCurrency = currency === 'SOL' ? 'USDC' : currency;
      const requiredBalance = finalUsdcAmount;
      const currentBalance = walletBalances[paymentCurrency];

      if (currentBalance < requiredBalance) {
        showNotification(
          'error',
          lang === 'ar'
            ? `Ø±ØµÙŠØ¯ ${paymentCurrency} ØºÙŠØ± ÙƒØ§ÙÙ`
            : `Insufficient ${paymentCurrency} balance`,
          8000
        );
        return;
      }

      const buyer = new PublicKey(address);
      const paymentMint = currency === 'USDT' ? ADDRESSES.USDT_MINT : ADDRESSES.USDC_MINT;
      const paymentVault = currency === 'USDT' ? ADDRESSES.USDT_VAULT : ADDRESSES.USDC_VAULT;
      const paymentAta = await getAssociatedTokenAddress(paymentMint, buyer);
      const lltyAta = await getAssociatedTokenAddress(ADDRESSES.LLTY_MINT, buyer);

      const tx = new Transaction();

      const lltyAccInfo = await connection.getAccountInfo(lltyAta);
      if (!lltyAccInfo) {
        tx.add(createAssociatedTokenAccountInstruction(buyer, lltyAta, buyer, ADDRESSES.LLTY_MINT));
      }

      const discriminator = new Uint8Array([189, 21, 230, 133, 247, 2, 110, 42]);
      const amountBytes = new BN(tokenAmountInSmallestUnit).toArrayLike(Buffer, 'le', 8);
      const data = Buffer.concat([Buffer.from(discriminator), amountBytes]);

      tx.add(
        new TransactionInstruction({
          keys: [
            { pubkey: ADDRESSES.PRESALE_PDA, isSigner: false, isWritable: true },
            { pubkey: buyer, isSigner: true, isWritable: true },
            { pubkey: paymentAta, isSigner: false, isWritable: true },
            { pubkey: lltyAta, isSigner: false, isWritable: true },
            { pubkey: paymentVault, isSigner: false, isWritable: true },
            { pubkey: ADDRESSES.LLTY_VAULT, isSigner: false, isWritable: true },
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
          ],
          programId: ADDRESSES.PROGRAM_ID,
          data,
        })
      );

      tx.feePayer = buyer;
      const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('confirmed');
      tx.recentBlockhash = blockhash;

      showNotification('info', lang === 'ar' ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©...' : 'Processing...');

      const signed = await walletProvider.signTransaction(tx);
      const effectiveConnection = connection || fallbackConnection;

      signature = await connection.sendRawTransaction(signed.serialize(), {
        skipPreflight: false,
        preflightCommitment: 'confirmed',
        maxRetries: 3
      });

      setTxSignature(signature);
      showNotification('info', lang === 'ar' ? 'Ø¬Ø§Ø±ÙŠ ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©...' : 'Confirming transaction...');

      const confirmation = await connection.confirmTransaction({
        signature,
        blockhash,
        lastValidBlockHeight
      }, 'confirmed');

      if (confirmation.value.err) {
        throw new Error('Transaction failed on-chain');
      }

      setTxStatus('confirmed');
      tokensReceived = totalTokens;

      // Verification
      try {
        const verification = await dbHelpers.verifyTransaction(signature, connection);
        if (!verification.verified) {
          console.warn('Transaction verification failed:', verification.reason);
        }
      } catch (verifyErr) {
        console.error('Verification error:', verifyErr);
      }

      // Database record
      try {
        const { data: dbRecord, error: dbError } = await dbHelpers.recordPurchase({
          walletAddress: address,
          tokensPurchased: tokensReceived,
          usdAmount: usdValue,
          currency,
          bonusPercentage,
          signature,
          phase: currentPhase,
          isVip: isVipPeriod
        });
        if (dbError) {
          console.error('Database error:', dbError);
        } else {
          console.log('Purchase recorded:', dbRecord);
          setTimeout(async () => {
            await dbHelpers.markVerified(signature);
          }, 5000);
        }
      } catch (dbErr) {
        console.error('Database exception:', dbErr);
      }

      // Update localStorage
      const stored = localStorage.getItem('llty_wallet');
      const dataStored = stored ? JSON.parse(stored) : { address, purchased: 0 };
      dataStored.purchased = (dataStored.purchased || 0) + tokensReceived;
      dataStored.lastPurchase = Date.now();
      dataStored.lastSignature = signature;
      localStorage.setItem('llty_wallet', JSON.stringify(dataStored));
      setPurchased(dataStored.purchased);

      const totalData = localStorage.getItem('llty_total_raised');
      const currentTotal = totalData ? JSON.parse(totalData) : { raised: 0, sold: 0 };
      currentTotal.raised += usdValue;
      currentTotal.sold += tokensReceived;
      localStorage.setItem('llty_total_raised', JSON.stringify(currentTotal));
      setTotalRaised(currentTotal.raised);
      setTotalLLTYSold(currentTotal.sold);

      if (isVipPeriod) {
        const vipData = localStorage.getItem('llty_vip_count');
        const currentVipCount = vipData ? parseInt(vipData) : 0;
        const newVipCount = Math.min(currentVipCount + 1, 50);
        localStorage.setItem('llty_vip_count', newVipCount.toString());
        setVipBuyersCount(newVipCount);
      }

      setAmount('');
      setCalculatedTokens(0);
      setBonusPercentage(0);
      await fetchBalances();

      showNotification(
        'success',
        `${lang === 'ar' ? 'Ù†Ø¬Ø­ Ø§Ù„Ø´Ø±Ø§Ø¡!' : 'Purchase successful!'} ${tokensReceived.toLocaleString()} LLTY${bonusPercentage > 0 ? ` (+${bonusPercentage}% bonus)` : ''}`
      );

      setTimeout(() => {
        showNotification(
          'info',
          `${lang === 'ar' ? 'Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©' : 'View transaction'}: https://explorer.solana.com/tx/${signature}?cluster=${NETWORK}`
        );
      }, 2000);

    } catch (err) {
      console.error('Buy tokens error:', err);
      setTxStatus('failed');

      let errorMessage = err.message || 'Unknown error';
      if (errorMessage.includes('User rejected')) {
        errorMessage = lang === 'ar' ? 'ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©' : 'Transaction cancelled';
      } else if (errorMessage.includes('Insufficient')) {
        errorMessage = lang === 'ar' ? 'Ø±ØµÙŠØ¯ ØºÙŠØ± ÙƒØ§ÙÙ' : errorMessage;
      }
      showNotification('error', `${lang === 'ar' ? 'Ø®Ø·Ø£' : 'Error'}: ${errorMessage}`);
    } finally {
      setLoading(false);
    }
  };

  const fetchPresaleData = async (conn) => {
    try {
      const totalData = localStorage.getItem('llty_total_raised');
      if (totalData) {
        const data = JSON.parse(totalData);
        setTotalRaised(data.raised || 0);
        setTotalLLTYSold(data.sold || 0);
      }
    } catch (err) {
      console.error('Failed to fetch presale data:', err);
    }
  };

  const fetchSolPrice = async () => {
    try {
      const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd');
      const data = await response.json();
      setSolPrice(data.solana?.usd || 150);
    } catch (err) {
      setSolPrice(150);
    }
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // EFFECTS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  // Auto-connect & localStorage restore
  useEffect(() => {
    const stored = localStorage.getItem('llty_wallet');
    if (stored && isConnected && address) {
      try {
        const data = JSON.parse(stored);
        const timeSinceConnect = Date.now() - (data.lastConnected || 0);
        const oneDayInMs = 24 * 60 * 60 * 1000;
        if (timeSinceConnect < oneDayInMs && data.address === address) {
          fetchBalances();
        } else {
          localStorage.removeItem('llty_wallet');
        }
      } catch (err) {
        console.error('Failed to restore wallet data:', err);
        localStorage.removeItem('llty_wallet');
      }
    }
  }, [isConnected, address]);

  // Save to localStorage when connected
  useEffect(() => {
    if (isConnected && address) {
      const walletData = {
        address,
        walletType: 'Reown',
        purchased: purchased,
        lastConnected: Date.now()
      };
      localStorage.setItem('llty_wallet', JSON.stringify(walletData));
    }
  }, [isConnected, address, purchased]);

  // Timer calculations
  useEffect(() => {
    const updateTimer = () => {
      const now = Date.now();
      if (now >= PRESALE_START && now < PUBLIC_START) {
        setIsVipPeriod(true);
        const vipRemaining = PUBLIC_START - now;
        setPhaseTimeRemaining({
          days: Math.floor(vipRemaining / (1000 * 60 * 60 * 24)),
          hours: Math.floor((vipRemaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)),
          minutes: Math.floor((vipRemaining % (1000 * 60 * 60)) / (1000 * 60)),
          seconds: Math.floor((vipRemaining % (1000 * 60)) / 1000)
        });
        setCurrentPhase(0);
        return;
      }
      setIsVipPeriod(false);
      if (now < PUBLIC_START) {
        setCurrentPhase(0);
        return;
      }
      if (now > PRESALE_END) {
        setPresaleEnded(true);
        setPhaseTimeRemaining({ days: 0, hours: 0, minutes: 0, seconds: 0 });
        return;
      }
      const elapsed = now - PUBLIC_START;
      const phase = Math.min(Math.floor(elapsed / PHASE_DURATION) + 1, 3);
      setCurrentPhase(phase);
      const phaseStart = PUBLIC_START + ((phase - 1) * PHASE_DURATION);
      const phaseEnd = phaseStart + PHASE_DURATION;
      const remaining = phaseEnd - now;
      setPhaseTimeRemaining({
        days: Math.floor(remaining / (1000 * 60 * 60 * 24)),
        hours: Math.floor((remaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)),
        minutes: Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60)),
        seconds: Math.floor((remaining % (1000 * 60)) / 1000)
      });
    };
    updateTimer();
    const interval = setInterval(updateTimer, 1000);
    return () => clearInterval(interval);
  }, []);

  // City carousel
  useEffect(() => {
    const interval = setInterval(() => {
      setCurrentCityIndex((prev) => (prev + 1) % citiesData.length);
    }, 5000);
    return () => clearInterval(interval);
  }, []);

  // Initialize
  useEffect(() => {
    const conn = new Connection(RPC_ENDPOINT, 'confirmed');
    fetchSolPrice();
    fetchPresaleData(conn);
  }, []);

  // Debounced buy function
  const buyTokensDebounced = useCallback(
    debounce(buyTokens, 2000, { leading: true, trailing: false }),
    [buyTokens]
  );

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // RENDER
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  return (
    <div className={`min-h-screen ${lang === 'ar' ? 'rtl' : 'ltr'} font-sans`}
      style={{
        background: 'linear-gradient(to bottom, #0f172a 0%, #1e293b 50%, #334155 100%)',
        color: '#f1f5f9'
      }}>

      {/* Notification */}
      {notification.show && (
        <div className="fixed top-24 right-4 z-50 animate-slide-in-right">
          <div className={`flex items-center gap-3 px-6 py-4 rounded-lg shadow-2xl border ${
            notification.type === 'success' ? 'bg-green-900/90 border-green-500' :
            notification.type === 'error' ? 'bg-red-900/90 border-red-500' :
            'bg-blue-900/90 border-blue-500'
          }`}>
            {notification.type === 'success' ? <CheckCircle className="text-green-400" size={24} /> :
             notification.type === 'error' ? <AlertCircle className="text-red-400" size={24} /> :
             <Clock className="text-blue-400" size={24} />}
            <span className="font-medium text-white">{notification.message}</span>
          </div>
        </div>
      )}

      <Header
        lang={lang}
        setLang={setLang}
        t={t}
        isConnected={isConnected}
        address={address}
        balance={balance}
        menuOpen={menuOpen}
        setMenuOpen={setMenuOpen}
        loading={loading}
        open={open}
        handleDisconnect={handleDisconnect}
        scrollToSection={scrollToSection}
        shortenAddress={shortenAddress}
      />

      <main className="container mx-auto px-4 py-8">
        <HeroSection
          lang={lang}
          t={t}
          isVipPeriod={isVipPeriod}
          currentPhase={currentPhase}
          presaleEnded={presaleEnded}
          phaseTimeRemaining={phaseTimeRemaining}
          getUrgencyMessage={getUrgencyMessage}
          totalRaised={totalRaised}
          totalLLTYSold={totalLLTYSold}
          PRESALE_TARGET={PRESALE_TARGET}
          PHASE_PRICES_DISPLAY={PHASE_PRICES_DISPLAY}
          progressPercentage={progressPercentage}
        />

        <VIPSection
          lang={lang}
          t={t}
          isVipPeriod={isVipPeriod}
          vipBuyersCount={vipBuyersCount}
          scrollToSection={scrollToSection}
        />

        <BonusTiersSection
          lang={lang}
          t={t}
        />

        <ReferralSection
          lang={lang}
          t={t}
          isConnected={isConnected}
          address={address}
          showNotification={showNotification}
        />

        <BuySection
          lang={lang}
          t={t}
          isConnected={isConnected}
          address={address}
          isVipPeriod={isVipPeriod}
          loading={loading}
          amount={amount}
          setAmount={setAmount}
          currency={currency}
          setCurrency={setCurrency}
          walletBalances={walletBalances}
          calculateTokenAmount={calculateTokenAmount}
          getBonusPercentage={getBonusPercentage}
          buyTokensDebounced={buyTokensDebounced}
          purchased={purchased}
          open={open}
        />

        {/* STAKING SECTION - NEW */}
        <StakingSection
          lang={lang}
          isConnected={isConnected}
          walletAddress={address}
          stakingData={stakingData}
          showNotification={showNotification}
        />

        {/* GOVERNANCE SECTION - NEW */}
        <GovernanceSection
          lang={lang}
          isConnected={isConnected}
          walletAddress={address}
          governanceData={governanceData}
          showNotification={showNotification}
        />

        <AboutSection
          lang={lang}
          t={t}
          scrollToSection={scrollToSection}
        />

        <CitiesSection
          lang={lang}
          t={t}
          citiesData={citiesData}
          currentCityIndex={currentCityIndex}
          setCurrentCityIndex={setCurrentCityIndex}
        />

        <TokenomicsSection
          lang={lang}
          t={t}
        />

        <RoadmapSection
          lang={lang}
          t={t}
          roadmapData={roadmapData}
        />

        <SecuritySection
          lang={lang}
          t={t}
        />
      </main>

        <Footer lang={lang} />
    </div>
  );
};

export default App;
